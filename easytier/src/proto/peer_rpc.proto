syntax = "proto3";

import "google/protobuf/timestamp.proto";
import "common.proto";

package peer_rpc;

message RoutePeerInfo {
  // means next hop in route table.
  uint32 peer_id = 1;
  common.UUID inst_id = 2;
  uint32 cost = 3;
  optional common.Ipv4Addr ipv4_addr = 4;
  repeated string proxy_cidrs = 5;
  optional string hostname = 6;
  common.NatType udp_stun_info = 7;
  google.protobuf.Timestamp last_update = 8;
  uint32 version = 9;
}

message PeerIdVersion {
  uint32 peer_id = 1;
  uint32 version = 2;
}

message RouteConnBitmap {
  repeated PeerIdVersion peer_ids = 1;
  bytes bitmap = 2;
}

message RoutePeerInfos { repeated RoutePeerInfo items = 1; }

message SyncRouteInfoRequest {
  uint32 my_peer_id = 1;
  uint64 my_session_id = 2;
  bool is_initiator = 3;
  RoutePeerInfos peer_infos = 4;
  RouteConnBitmap conn_bitmap = 5;
}

enum SyncRouteInfoError {
  DuplicatePeerId = 0;
  Stopped = 1;
}

message SyncRouteInfoResponse {
  bool is_initiator = 1;
  uint64 session_id = 2;
  optional SyncRouteInfoError error = 3;
}

service OspfRouteRpc {
  // Generates a "hello" greeting based on the supplied info.
  rpc SyncRouteInfo(SyncRouteInfoRequest) returns (SyncRouteInfoResponse);
}

message GetIpListRequest {}

message GetIpListResponse {
    common.Ipv4Addr public_ipv4 = 1;
    repeated common.Ipv4Addr interface_ipv4s = 2;
    common.Ipv6Addr public_ipv6 = 3;
    repeated common.Ipv6Addr interface_ipv6s = 4;
    repeated common.Url listeners = 5;
}

service DirectConnectorRpc {
  rpc GetIpList(GetIpListRequest) returns (GetIpListResponse);
}
